---
title: "Js 돌아보기1"
datePublished: Wed Jun 25 2025 14:40:58 GMT+0000 (Coordinated Universal Time)
cuid: cmcc2avdk000102l45g0l7ir8
slug: js-1-1-1-1

---

“자바스크립트.. 처음은 쉽지만, 갈수록 복잡하다?!”

자바스크립트를 공부하다 보면 처음엔 쉽다고 느끼지만, 어느 순간부터 this, 스코프, 클로저, 실행 컨텍스트 같은 개념들이 쏟아지며 “왜 이렇게 복잡하지?”라는 생각이 들곤 합니다.  
이 글은 자바스크립트가 **왜 그렇게 설계되었고**, **무엇을 알아야 제대로 다룰 수 있는지**를 풀어보려 합니다.

---

## ☕️ 시작: JS는 원래 간단한 언어가 목적이였다.

자바스크립트는 원래 웹페이지에 **간단한 동작**을 넣기 위한 언어로 시작했습니다.  
JS의 설계자는 복잡한 클래스 구조 없이도 객체지향이 가능하도록 만들고자 했습니다

그 결과, 자바스크립트는 아래와 같은 특성을 갖게 됩니다:

* 클래스를 쓰지 않고도 객체를 쉽게 만들 수 있고
    
* 객체를 서로 연결해서 상속을 흉내낼 수 있고
    
* 타입 없이도 **비슷한 구조면 그냥 작동**하고
    
* 함수도 자유롭게 넘겨서 간단하게 로직 구성 가능
    

그래서 JS는 **클래스 없는 객체지향 + 함수 중심 설계**의 언어가 되었습니다.

---

## 🧱 클래스 없이 객체지향?

JS는 클래스 없이도, **그냥 객체를 바로 만들 수 있게** 했습니다. 아래 코드를 보시다시피 JS에서 객체를 만드는 건 정말 쉽습니다:

```javascript
const cat = {
  name: "냥이",
  age: 1
};
```

하지만 이런 cat 객체를 **100마리 만들려면?**

```javascript
const cat1 = { ... };
const cat2 = { ... };
// 중복 지옥
```

매번 cat1, cat2, cat3을 직접 만들 수 없으니, 이때는 "공통 구조를 가진 객체 여러 개"를 만들기 위해 **함수나 class**가 필요합니다. 따라서 JS는 클래스가 아닌 **함수로 객체 생성 역할**을 대신했습니다.

```javascript
function Cat(name, age) {
  this.name = name;
  this.age = age;
}
```

---

## 🤯 그런데 this는 왜 이렇게 복잡한가요?

여기서 등장하는 개념이 바로 `this`입니다.  
자바나 C++에선 `this`가 항상 "현재 인스턴스"를 가리키죠.  
하지만 JS는 this가 이렇게 고정적이지 않습니다.

```javascript
function sayHi() {
  console.log(this);
}

sayHi();           // window or undefined
obj.sayHi();       // obj
new sayHi();       // 새로 만든 객체
```

> 똑같은 코드인데 `this`가 계속 바뀝니다. 왜일까요?

👉 자바스크립트는 **함수를 호출한 방식에 따라** `this`를 동적으로 바인딩합니다.  
즉, 정의된 위치가 아니라 **실행되는 시점**에서 어떤 객체가 `this`가 될지를 결정하죠.  
이걸 설명하기 위해 나온 개념이 바로 **실행 컨텍스트**입니다.

---

## 🧠 실행 컨텍스트가 필요한 이유

정적 언어(Java, C++)는 컴파일할 때 모든 스코프, 변수, this가 결정됩니다.  
하지만 자바스크립트는 런타임 호출 방식인 동적언어이기때문에, **코드를 실행하면서** 아래 같은 일이 벌어져요:

* 변수와 함수가 실행 중에 생기고
    
* `this`는 호출 방식 따라 바뀌고
    
* 클로저로 외부 변수를 기억하고
    
* 객체는 런타임에 속성이 추가/삭제됨
    

그래서 JS는 단순한 **스택 프레임**만으로는 부족하고, 코드가 "어떻게 실행되는지"까지 완전히 기술하는 구조의 실행 컨텍스트가 필요합니다.  
즉 **this, 스코프 체인, 클로저, 변수 환경 같은 코드 실행에 필요한 모든 정보를 담은 구조**가 필요하죠.

> 즉, 고정은 명확하지만 유연하지 못하고, 동적은 헷갈리지만 유연합니다.  
> 자바스크립트는 **그 유연함을 택한 언어에 가깝습니다.**

---

## 🧩 this, 클로저, 실행 컨텍스트는 연결되어 있다

```javascript
function outer() {
  const name = "JS";
  return function inner() {
    console.log(name);
  }
}

const fn = outer();
fn(); // 클로저
```

여기서 `inner()`는 이미 `outer()`가 끝났는데도 `name`을 기억하고 있어요.  
이건 **실행 컨텍스트 안에 있는 렉시컬 환경**이 유지되기 때문입니다.  
inner() 함수가 **선언될 때**, **자신이 정의된 스코프(=outer의 렉시컬 환경)를 참조로 저장해 둡니다.**  
→ 클로저가 가능한 이유!

---

### 실행 컨텍스트 구조 – 최신 기준

```javascript
Execution Context
├── LexicalEnvironment
│   ├── EnvironmentRecord         ← 변수 저장
│   └── OuterEnvironmentReference ← 상위 스코프 연결
├── VariableEnvironment (≒ LexicalEnvironment)
├── ThisBinding
```

| 구성 요소 | 설명 |
| --- | --- |
| **LexicalEnvironment** | 변수와 함수 선언이 담긴 공간 + 외부 스코프 참조 포함 |
| **EnvironmentRecord** | 변수, 함수, 매개변수 저장소 (`let`, `const`, `function`) |
| **OuterEnvironmentReference** | 스코프 체인 연결을 위한 상위 렉시컬 환경 참조 |
| **VariableEnvironment** | 과거엔 `var` 전용 저장소였으나, 현재는 대부분 **LexicalEnvironment와 동일하게 처리됨** |
| **ThisBinding** | 해당 실행 컨텍스트의 `this`가 누구인지 저장 |

자바스크립트 초기에는 이렇게 나눴어요:

* `VariableEnvironment`: `var`, `function`
    
* `LexicalEnvironment`: `let`, `const`
    

그런데 **ES6 이후로는 거의 동일하게 다룸**.

→ 최신 JS 엔진(V8 등)은 `LexicalEnvironment` 하나로 통일된 구조로 관리합니다.

그래서 결론!

> 실행 컨텍스트 안에 렉시컬 환경이 있고, 그 렉시컬 환경 안에 **변수도 있고, 스코프 연결도 있고**,
> 
> 그래서 클로저가 가능하고, this 바인딩도 그 컨텍스트에 함께 있음.

### ✅ 그래서 inner 함수가 outer의 변수를 접근할 수 있는 이유는?

> inner 함수가 선언될 때, outer의 `LexicalEnvironment` 전체를 캡처함  
> (= 그 안에 있는 변수 정보 + 스코프 체인 정보까지 포함)

이 구조가 **스코프 체인**을 따라 올라가게 해 주는 핵심!!

---

### ✨ 자바스크립트를 잘 쓰기 위한 핵심 요약

* 클래스가 없어도 객체지향이 가능한 이유? →함수를 생성자처럼 쓰고, 프로토타입을 통해 객체를 연결(상속)하기 때문
    
* `this`가 어려운 이유? → 호출 방식마다 다르기 때문
    
* `클로저`가 가능한 이유? → 렉시컬 환경을 참조로 기억하기 때문
    
* 실행 흐름을 추적하려면? → 실행 컨텍스트와 이벤트 루프 개념 필요
    

> 자바스크립트는 "클래스 없는 객체지향"과 "동적 함수 기반 실행"을 동시에 추구한,  
> **함수형 + 객체지향언어**입니다.  
> 그렇기에 **내부 동작 원리를 이해하지 않으면**, 자바스크립트를 **제대로 다루기 어려운 것 같습니다.**

다음 포스팅에는 프로토타입에 대해 자세히 다루도록 하겠습니다.