---
title: "프로젝트 회고:  프론트엔드 구조 설계와 실무적 판단"
datePublished: Sat May 03 2025 13:44:05 GMT+0000 (Coordinated Universal Time)
cuid: cma89xk0j000a09lbg7vcgpoz
slug: 7zse66gc7kcd7yq4io2ajoqzodogio2uhouhoo2kuoyxloutncdqtazsobag7isk6roe7jmaioylpoustoyggsdtjjdri6g

---

이번 프로젝트에서 초기에 혼자 프론트엔드를 맡아 진행하게 되어, 프로젝트 구조와 설계에 대해 깊이 고민해볼 수 있는 계기가 되었습니다. 특히 프론트엔드 개발과 관련된 서버 환경 및 인증 흐름에 대해 실무적인 고민과 시행착오를 경험했고, 이를 정리해보려 합니다.

### 1\. **백엔드 구조와의 조율**

프로젝트 착수 전, 요구사항을 명확히 하기 위해 백엔드 리드분과 협의하였고, 프론트엔드는 React로 진행하기로 결정되었습니다. 그러나 이후에 알고보니(?) 백엔드 리드분이 생각하셨던 프론트가 Nuxt 같은 서버 사이드 렌더링 환경에 익숙해 있었고, React와 같은 서버리스 프론트엔드 프레임워크에 대한 이해도가 낮은 상황이었습니다 그 결과, 백엔드에서 제공된 API 구조는 클라이언트에서 직접 호출하기에는 보안상 문제가 있는 형태였습니다.

예를 들어, 인증 관련 API에 `apikey`와 같은 민감한 정보를 직접 포함시켜야 하는 상황이 있었고, 이를 브라우저 환경에서 처리하면 정보가 노출될 수 있다는 점을 설명드린 후에야 문제의 심각성을 인지하셨습니다. 이에 따라 백엔드 측에 BFF(BBackend for Frontend) 도입 또는 API 설계 재고를 요청했지만, 일정 및 유지보수 등의 이유로 어렵다는 답변을 받게 되었습니다.

### 2\. **BFF 도입: React + Express vs. Next.js**

결과적으로 프론트엔드에서 직접 BFF를 관리해달라고 요청을 받게 되었고, 초기 세팅 단계인 점을 고려해 **React + Express** 대신 **Next.js**를 도입해 하나의 프로젝트에서 프론트와 BFF를 통합적으로 관리하는 방향으로 전환했습니다. 개발이 이미 진행된 상황이었다면 React + Express 구조를 선택했을 것 같습니다.

### 3\. **인증 및 API 서버 구조**

* **\[인증 서버\]**
    
    * 요청 시 `apikey`를 포함해 `accessToken`과 `refreshToken`을 응답받는 구조
        
* **\[API 서버\]**
    
    * 실제로 자주 호출하게 될 API
        
    * **인증 서버애서 받은** `accessToken`이 헤더에 포함해야 정상응답 가능
        

### 4\. **Next.js 구조 설계**

Next.js 환경에서 고려했던 세 가지 방식입니다.

1. **Server Components + Route Handlers + Server Actions 조합으로 서버에서 모든 요청 처리**
    
    * 서버 렌더링 + \[인증\]과 \[API\] 요청을 모두 서버에서 처리
        
2. 브라우저 렌더링 + Next.js API Routes를 통한 인증 및 API 처리
    
3. 브라우저 렌더링 + 인증만 서버 처리, 이후 API는 클라이언트 직접 호출
    

처음에는 1번 구조를 고려했지만, 단순한 API 키 보호 목적이라면 오버 엔지니어링이라는 피드백과 서버 환경에 대한 경험이 부족한 점, 현실적인 러닝 커브를 고려하라는 조언도 받았습니다.

추가적으로 피드백 받았던 부분은 **기술적인 최선**이 항상 **프로젝트 전체의 최선**은 아니라는 점이었습니다. 실무에서는 기술적인 판단 외에도 **팀의 역량, 일정, 운영 효율성 등 다양한 요소**를 함께 고려해야 하며, 때로는 완벽한 기술 설계보다는 **상황과 환경에 맞는 선택**이 프로젝트를 더 원활하게 이끌 수 있다는 점이였습니다. 비합리적으로 보일 수 있는 선택도, 그 맥락을 충분히 이해하고 판단한다면 오히려 더 합리적인 결정이 될 수 있다는 사실을 깨닫게 되었습니다. 프로젝트가 커질수록 완벽한 구조보다는, **비합리성을 최소화하고 수용 가능한 형태로 조율하는 능력**이 더 중요하다는 것도 함께 느꼈습니다.

그래서 2번과 3번을 고민하다 추후 보안 심사를 대비해야 한다는 점과 풀스택 개발자 투입이 예정되어 있다는 점을 고려해 2번으로 정하게 되었습니다.

### 5\. **성능과 트래픽 고려**

다만 서버 환경에 익숙하지 않았던 만큼, Next.js 서버가 프록시 역할을 하면서 **트래픽이 몰릴 경우 성능 저하가 발생하지 않을까?** 하는 막연한 걱정이 들었습니다. 그러나 이때, 먼저 걱정부터 하기보다 그 판단에 필요한 정보를 먼저 확보해야 한다며 순서가 잘못되었다는 피드백을 받고 또 한 번 아차 싶었습니다.

이에 백엔드 팀과 사업부에 가서 예상 트래픽을 여쭤보았습니다.:

* 최대 트래픽: 5,000건 이하 예상
    
* 평균 : 약 3,000 건 예상
    

해당 트래픽 기반으로 DevOps팀에 여쭤보았습니다. 이 정도 수준의 트래픽은 단순 프록시 역할만 수행하는 Next.js 서버에 큰 부담이 아니라는 말씀을 해주셨습니다. 프록시 처리는 연산 부담이 거의 없기 때문에 CPU 사용량이 낮고, 동시 요청 수가 많아질수록 네트워크 대역폭과 메모리 사용량이 먼저 병목이 되기 때문에, **추후에 트래픽이 증가하더라도 하더라도 DevOps팀에서 충분히 대응 가능한 영역**이라는 점을 명확히 알게되었습니다.

### 6\. **마무리**

이번 경험을 통해 단순히 기술적 선택만이 아닌, 실제 상황과 환경에 맞는 **유연한 판단**과 판단의 이유를 명확히 아는 것의 중요성을 깊이 체감했습니다.

특히 프로젝트가 커질수록 완전히 합리적인 선택만을 할 수는 없고, 그런 상황에서 최선의 선택을 찾아가는 역량이 좋은 개발자의 자질 중 하나임을 느꼈습니다.